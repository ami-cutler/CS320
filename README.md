# CS320
Portfolio of assignments from CS-320

**How can I ensure that my code, program, or software is functional and secure?**

Ensuring functionality and security begins with understanding project requirements and defining clear objectives. For example, in the ContactManager, TaskManager, and AppointmentManager projects, specific functionalities were needed to manage contacts, tasks, and appointments while ensuring unique IDs, character limits, and validation were adhered to. These requirements guided both the design and testing processes. Using Unit testing, like JUnit, to test individual methods and classes, was critical for ensuring the code works as expected. Testing for edge cases, boundary conditions, and invalid inputs helped catch potential failures early. Integration testing would ensure that components interact correctly, as seen when confirming that TaskManager could handle task creation, updating, and deletion smoothly. To maintain functionality, test automation and continuous integration (CI) pipelines can be set up to frequently run tests, helping avoid regression bugs as the project evolves.

Secure coding practices begin with proper input validation to prevent malformed or malicious data from being processed. In the ContactManager project validating phone numbers and character lengths helped prevent vulnerabilities like buffer overflows or SQL injection attacks. Additionally, sensitive data should always be encrypted, both when stored (data at rest) and during transmission (data in transit), ensuring that compromised data is unreadable. Implementing access control mechanisms is crucial, even if it isn’t a direct requirement in projects, as managing user permissions is essential when dealing with personal information. Secure applications need robust error handling to avoid exposing sensitive details, while logging can be employed to monitor suspicious activities without compromising sensitive data.

**How do I interpret user needs and incorporate them into a program?**

To create a program that meets user needs, it's essential to follow a user-centered development process. This starts with requirements gathering, where engaging with stakeholders helps define key features based on how users interact with tasks, contacts, or appointments. For example, understanding the importance of easily updating tasks or deleting appointments helps shape the design. Creating user stories can further clarify these needs. Next, prototyping and seeking user feedback allows for early validation of ideas. Whether designing a website or the appointment system, presenting users with prototypes or demos ensures that functionality meets their expectations. Iteration is key—incorporating user feedback and continuously testing ensures the program evolves to fit their needs. Finally, feature prioritization ensures that the most valuable and effort-efficient features are addressed first, such as focusing on task creation in the TaskManager project, while still considering the importance of updates and deletions.

**How do I approach designing software?**

Designing software effectively requires balancing structure, functionality, and scalability. One key approach is modular design, where a program is broken down into smaller, manageable components. For instance, in the ContactManager projects, functions like adding, updating, and deleting contacts could be isolated into distinct modules or classes, making the software more maintainable and reducing the risk of changes in one area affecting others. Object-oriented principles, such as encapsulation and inheritance, further enhance this modularity by creating reusable and maintainable code, as reflected in the use of classes for Contact, Task, and Appointment objects. Scalability is also crucial; for example, if the ContactManager were expanded into a full Customer Relationship Management (CRM) system, it would require an architectural foundation that supports new features like contact categorization or external service integration. Even without a UI, user experience (UX) remains important—clear commands and error messages improve interactions in a command-line interface or API. Security should be integrated from the start, as seen in an appointment manager designed with encrypted storage for sensitive data. Finally, thorough documentation supports both development and maintenance by clarifying how functions work, how tests are conducted, and how new developers can contribute.
